{
  "version": 3,
  "sources": ["../src/index.ts", "../src/storage/keys.ts", "../src/storage/storage.ts", "../src/utils/base64url.ts", "../src/utils/crypto.ts", "../src/auth/dpop.ts", "../src/auth/pkce.ts", "../src/auth/session.ts", "../src/auth/oauth.ts", "../src/graphql.ts", "../src/client.ts", "../src/errors.ts"],
  "sourcesContent": ["export { QuicksliceClient, QuicksliceClientOptions, QueryOptions, User } from './client';\nexport { SessionInfo } from './auth/session';\nexport {\n  QuicksliceError,\n  LoginRequiredError,\n  NetworkError,\n  OAuthError,\n} from './errors';\n\nimport { QuicksliceClient, QuicksliceClientOptions } from './client';\n\n/**\n * Create and initialize a Quickslice client\n */\nexport async function createQuicksliceClient(\n  options: QuicksliceClientOptions\n): Promise<QuicksliceClient> {\n  const client = new QuicksliceClient(options);\n  await client.init();\n  return client;\n}\n", "/**\n * Storage key factory - generates namespaced keys\n *\n * With cookie-based auth, we only need to store:\n * - OAuth flow state (sessionStorage, ephemeral)\n * - Client ID (for OAuth flow)\n *\n * Tokens are stored server-side and accessed via HTTP-only cookies.\n */\nexport interface StorageKeys {\n  clientId: string;\n  codeVerifier: string;\n  oauthState: string;\n  redirectUri: string;\n}\n\nexport function createStorageKeys(namespace: string): StorageKeys {\n  return {\n    clientId: `quickslice_${namespace}_client_id`,\n    codeVerifier: `quickslice_${namespace}_code_verifier`,\n    oauthState: `quickslice_${namespace}_oauth_state`,\n    redirectUri: `quickslice_${namespace}_redirect_uri`,\n  };\n}\n\nexport type StorageKey = string;\n", "import { StorageKeys } from './keys';\n\n/**\n * Create a namespaced storage interface\n *\n * With cookie-based auth, we only store OAuth flow state.\n * Tokens are managed server-side via HTTP-only cookies.\n */\nexport function createStorage(keys: StorageKeys) {\n  return {\n    get(key: keyof StorageKeys): string | null {\n      const storageKey = keys[key];\n      // OAuth flow state stays in sessionStorage (per-tab, ephemeral)\n      if (key === 'codeVerifier' || key === 'oauthState' || key === 'redirectUri') {\n        return sessionStorage.getItem(storageKey);\n      }\n      // Client ID stored in localStorage (shared across tabs)\n      return localStorage.getItem(storageKey);\n    },\n\n    set(key: keyof StorageKeys, value: string): void {\n      const storageKey = keys[key];\n      if (key === 'codeVerifier' || key === 'oauthState' || key === 'redirectUri') {\n        sessionStorage.setItem(storageKey, value);\n      } else {\n        localStorage.setItem(storageKey, value);\n      }\n    },\n\n    remove(key: keyof StorageKeys): void {\n      const storageKey = keys[key];\n      sessionStorage.removeItem(storageKey);\n      localStorage.removeItem(storageKey);\n    },\n\n    clear(): void {\n      (Object.keys(keys) as Array<keyof StorageKeys>).forEach((key) => {\n        const storageKey = keys[key];\n        sessionStorage.removeItem(storageKey);\n        localStorage.removeItem(storageKey);\n      });\n    },\n  };\n}\n\nexport type Storage = ReturnType<typeof createStorage>;\n", "/**\n * Base64 URL encode a buffer (Uint8Array or ArrayBuffer)\n */\nexport function base64UrlEncode(buffer: ArrayBuffer | Uint8Array): string {\n  const bytes = buffer instanceof Uint8Array ? buffer : new Uint8Array(buffer);\n  let binary = '';\n  for (let i = 0; i < bytes.length; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return btoa(binary)\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_')\n    .replace(/=+$/, '');\n}\n\n/**\n * Generate a random base64url string\n */\nexport function generateRandomString(byteLength: number): string {\n  const bytes = new Uint8Array(byteLength);\n  crypto.getRandomValues(bytes);\n  return base64UrlEncode(bytes);\n}\n", "import { base64UrlEncode } from './base64url';\n\n/**\n * SHA-256 hash, returned as base64url string\n */\nexport async function sha256Base64Url(data: string): Promise<string> {\n  const encoder = new TextEncoder();\n  const hash = await crypto.subtle.digest('SHA-256', encoder.encode(data));\n  return base64UrlEncode(hash);\n}\n\n/**\n * Generate an 8-character namespace hash from clientId\n */\nexport async function generateNamespaceHash(clientId: string): Promise<string> {\n  const encoder = new TextEncoder();\n  const hash = await crypto.subtle.digest('SHA-256', encoder.encode(clientId));\n  const hashArray = Array.from(new Uint8Array(hash));\n  const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\n  return hashHex.substring(0, 8);\n}\n\n/**\n * Sign a JWT with an ECDSA P-256 private key\n */\nexport async function signJwt(\n  header: Record<string, unknown>,\n  payload: Record<string, unknown>,\n  privateKey: CryptoKey\n): Promise<string> {\n  const encoder = new TextEncoder();\n\n  const headerB64 = base64UrlEncode(encoder.encode(JSON.stringify(header)));\n  const payloadB64 = base64UrlEncode(encoder.encode(JSON.stringify(payload)));\n\n  const signingInput = `${headerB64}.${payloadB64}`;\n\n  const signature = await crypto.subtle.sign(\n    { name: 'ECDSA', hash: 'SHA-256' },\n    privateKey,\n    encoder.encode(signingInput)\n  );\n\n  const signatureB64 = base64UrlEncode(signature);\n\n  return `${signingInput}.${signatureB64}`;\n}\n", "import { generateRandomString } from '../utils/base64url';\nimport { sha256Base64Url, signJwt } from '../utils/crypto';\n\nconst DB_VERSION = 1;\nconst KEY_STORE = 'dpop-keys';\nconst KEY_ID = 'dpop-key';\n\ninterface DPoPKeyData {\n  id: string;\n  privateKey: CryptoKey;\n  publicJwk: JsonWebKey;\n  createdAt: number;\n}\n\n// Cache database connections per namespace\nconst dbPromises = new Map<string, Promise<IDBDatabase>>();\n\nfunction getDbName(namespace: string): string {\n  return `quickslice-oauth-${namespace}`;\n}\n\nfunction openDatabase(namespace: string): Promise<IDBDatabase> {\n  const existing = dbPromises.get(namespace);\n  if (existing) return existing;\n\n  const promise = new Promise<IDBDatabase>((resolve, reject) => {\n    const request = indexedDB.open(getDbName(namespace), DB_VERSION);\n\n    request.onerror = () => reject(request.error);\n    request.onsuccess = () => resolve(request.result);\n\n    request.onupgradeneeded = (event) => {\n      const db = (event.target as IDBOpenDBRequest).result;\n      if (!db.objectStoreNames.contains(KEY_STORE)) {\n        db.createObjectStore(KEY_STORE, { keyPath: 'id' });\n      }\n    };\n  });\n\n  dbPromises.set(namespace, promise);\n  return promise;\n}\n\nasync function getDPoPKey(namespace: string): Promise<DPoPKeyData | null> {\n  const db = await openDatabase(namespace);\n  return new Promise((resolve, reject) => {\n    const tx = db.transaction(KEY_STORE, 'readonly');\n    const store = tx.objectStore(KEY_STORE);\n    const request = store.get(KEY_ID);\n\n    request.onerror = () => reject(request.error);\n    request.onsuccess = () => resolve(request.result || null);\n  });\n}\n\nasync function storeDPoPKey(\n  namespace: string,\n  privateKey: CryptoKey,\n  publicJwk: JsonWebKey\n): Promise<void> {\n  const db = await openDatabase(namespace);\n  return new Promise((resolve, reject) => {\n    const tx = db.transaction(KEY_STORE, 'readwrite');\n    const store = tx.objectStore(KEY_STORE);\n    const request = store.put({\n      id: KEY_ID,\n      privateKey,\n      publicJwk,\n      createdAt: Date.now(),\n    });\n\n    request.onerror = () => reject(request.error);\n    request.onsuccess = () => resolve();\n  });\n}\n\nexport async function getOrCreateDPoPKey(namespace: string): Promise<DPoPKeyData> {\n  const keyData = await getDPoPKey(namespace);\n\n  if (keyData) {\n    return keyData;\n  }\n\n  // Generate new P-256 key pair\n  const keyPair = await crypto.subtle.generateKey(\n    { name: 'ECDSA', namedCurve: 'P-256' },\n    false, // NOT extractable - critical for security\n    ['sign']\n  );\n\n  // Export public key as JWK\n  const publicJwk = await crypto.subtle.exportKey('jwk', keyPair.publicKey);\n\n  // Store in IndexedDB\n  await storeDPoPKey(namespace, keyPair.privateKey, publicJwk);\n\n  return {\n    id: KEY_ID,\n    privateKey: keyPair.privateKey,\n    publicJwk,\n    createdAt: Date.now(),\n  };\n}\n\n/**\n * Create a DPoP proof JWT\n */\nexport async function createDPoPProof(\n  namespace: string,\n  method: string,\n  url: string,\n  accessToken: string | null = null\n): Promise<string> {\n  const keyData = await getOrCreateDPoPKey(namespace);\n\n  // Strip WebCrypto-specific fields from JWK for interoperability\n  const { kty, crv, x, y } = keyData.publicJwk;\n  const minimalJwk = { kty, crv, x, y };\n\n  const header = {\n    alg: 'ES256',\n    typ: 'dpop+jwt',\n    jwk: minimalJwk,\n  };\n\n  const payload: Record<string, unknown> = {\n    jti: generateRandomString(16),\n    htm: method,\n    htu: url,\n    iat: Math.floor(Date.now() / 1000),\n  };\n\n  // Add access token hash if provided (for resource requests)\n  if (accessToken) {\n    payload.ath = await sha256Base64Url(accessToken);\n  }\n\n  return await signJwt(header, payload, keyData.privateKey);\n}\n\n/**\n * Clear DPoP keys from IndexedDB\n */\nexport async function clearDPoPKeys(namespace: string): Promise<void> {\n  const db = await openDatabase(namespace);\n  return new Promise((resolve, reject) => {\n    const tx = db.transaction(KEY_STORE, 'readwrite');\n    const store = tx.objectStore(KEY_STORE);\n    const request = store.clear();\n\n    request.onerror = () => reject(request.error);\n    request.onsuccess = () => resolve();\n  });\n}\n", "import { base64UrlEncode, generateRandomString } from '../utils/base64url';\n\n/**\n * Generate a PKCE code verifier (32 random bytes, base64url encoded)\n */\nexport function generateCodeVerifier(): string {\n  return generateRandomString(32);\n}\n\n/**\n * Generate a PKCE code challenge from a verifier (SHA-256, base64url encoded)\n */\nexport async function generateCodeChallenge(verifier: string): Promise<string> {\n  const encoder = new TextEncoder();\n  const data = encoder.encode(verifier);\n  const hash = await crypto.subtle.digest('SHA-256', data);\n  return base64UrlEncode(hash);\n}\n\n/**\n * Generate a random state parameter for CSRF protection\n */\nexport function generateState(): string {\n  return generateRandomString(16);\n}\n", "/**\n * Session management for cookie-based authentication\n *\n * Handles server-side session creation and management via HTTP-only cookies.\n * DPoP keys remain client-side for ATProto compatibility.\n */\n\nimport { getOrCreateDPoPKey } from './dpop';\nimport { sha256Base64Url } from '../utils/crypto';\n\nexport interface SessionInfo {\n  authenticated: boolean;\n  did: string | null;\n  handle: string | null;\n}\n\nexport interface CreateSessionOptions {\n  clientId: string;\n  userDid?: string;\n  atpSessionId?: string;\n}\n\n/**\n * Create a new session on the server after OAuth callback\n *\n * This is called after the OAuth token exchange to establish a cookie-based session.\n * The server stores the tokens and returns a session cookie.\n */\nexport async function createSession(\n  serverUrl: string,\n  namespace: string,\n  options: CreateSessionOptions\n): Promise<SessionInfo> {\n  // Get DPoP key to compute JKT for session binding\n  const keyData = await getOrCreateDPoPKey(namespace);\n  const dpopJkt = await computeJkt(keyData.publicJwk);\n\n  const response = await fetch(`${serverUrl}/api/client/session`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    credentials: 'include', // Include cookies in the response\n    body: JSON.stringify({\n      clientId: options.clientId,\n      dpopJkt,\n      userDid: options.userDid,\n      atpSessionId: options.atpSessionId,\n    }),\n  });\n\n  if (!response.ok) {\n    const errorData = await response.json().catch(() => ({}));\n    throw new Error(\n      `Failed to create session: ${errorData.message || response.statusText}`\n    );\n  }\n\n  return await response.json();\n}\n\n/**\n * Get current session status from the server\n *\n * Returns session info if a valid session cookie exists, otherwise returns\n * an unauthenticated session info.\n */\nexport async function getSession(serverUrl: string): Promise<SessionInfo> {\n  const response = await fetch(`${serverUrl}/api/client/session`, {\n    method: 'GET',\n    credentials: 'include', // Include session cookie\n  });\n\n  if (!response.ok) {\n    // Return unauthenticated on error\n    return {\n      authenticated: false,\n      did: null,\n      handle: null,\n    };\n  }\n\n  return await response.json();\n}\n\n/**\n * Destroy the current session (logout)\n *\n * Clears the session cookie and server-side session data.\n */\nexport async function destroySession(serverUrl: string): Promise<void> {\n  await fetch(`${serverUrl}/api/client/session`, {\n    method: 'DELETE',\n    credentials: 'include', // Include session cookie\n  });\n  // Ignore response - session is destroyed regardless\n}\n\n/**\n * Compute JWK Thumbprint (JKT) for a public key\n * Per RFC 7638: SHA-256 hash of the canonical JWK representation\n */\nasync function computeJkt(jwk: JsonWebKey): Promise<string> {\n  // Build canonical JWK representation (sorted keys, required members only)\n  // For EC keys: crv, kty, x, y\n  const canonical = JSON.stringify({\n    crv: jwk.crv,\n    kty: jwk.kty,\n    x: jwk.x,\n    y: jwk.y,\n  });\n\n  return await sha256Base64Url(canonical);\n}\n", "import { Storage } from '../storage/storage';\nimport { createDPoPProof, clearDPoPKeys } from './dpop';\nimport { generateCodeVerifier, generateCodeChallenge, generateState } from './pkce';\nimport { createSession, destroySession, SessionInfo } from './session';\n\nexport interface LoginOptions {\n  handle?: string;\n  redirectUri?: string;\n  scope?: string;\n}\n\n/**\n * Initiate OAuth login flow with PKCE\n */\nexport async function initiateLogin(\n  storage: Storage,\n  authorizeUrl: string,\n  clientId: string,\n  options: LoginOptions = {}\n): Promise<void> {\n  const codeVerifier = generateCodeVerifier();\n  const codeChallenge = await generateCodeChallenge(codeVerifier);\n  const state = generateState();\n\n  // Build redirect URI (use provided or derive from current page)\n  const redirectUri = options.redirectUri || (window.location.origin + window.location.pathname);\n\n  // Store for callback\n  storage.set('codeVerifier', codeVerifier);\n  storage.set('oauthState', state);\n  storage.set('clientId', clientId);\n  storage.set('redirectUri', redirectUri);\n\n  // Build authorization URL\n  const params = new URLSearchParams({\n    client_id: clientId,\n    redirect_uri: redirectUri,\n    response_type: 'code',\n    code_challenge: codeChallenge,\n    code_challenge_method: 'S256',\n    state: state,\n  });\n\n  if (options.handle) {\n    params.set('login_hint', options.handle);\n  }\n\n  if (options.scope) {\n    params.set('scope', options.scope);\n  }\n\n  window.location.href = `${authorizeUrl}?${params.toString()}`;\n}\n\n/**\n * Handle OAuth callback - exchange code for tokens and create session\n * Returns session info if callback was handled, null if not a callback\n */\nexport async function handleOAuthCallback(\n  storage: Storage,\n  namespace: string,\n  tokenUrl: string,\n  serverUrl: string\n): Promise<SessionInfo | null> {\n  const params = new URLSearchParams(window.location.search);\n  const code = params.get('code');\n  const state = params.get('state');\n  const error = params.get('error');\n\n  if (error) {\n    throw new Error(\n      `OAuth error: ${error} - ${params.get('error_description') || ''}`\n    );\n  }\n\n  if (!code || !state) {\n    return null; // Not a callback\n  }\n\n  // Verify state\n  const storedState = storage.get('oauthState');\n  if (state !== storedState) {\n    throw new Error('OAuth state mismatch - possible CSRF attack');\n  }\n\n  // Get stored values\n  const codeVerifier = storage.get('codeVerifier');\n  const clientId = storage.get('clientId');\n  const redirectUri = storage.get('redirectUri');\n\n  if (!codeVerifier || !clientId || !redirectUri) {\n    throw new Error('Missing OAuth session data');\n  }\n\n  // Exchange code for tokens with DPoP\n  const dpopProof = await createDPoPProof(namespace, 'POST', tokenUrl);\n\n  const tokenResponse = await fetch(tokenUrl, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n      DPoP: dpopProof,\n    },\n    body: new URLSearchParams({\n      grant_type: 'authorization_code',\n      code: code,\n      redirect_uri: redirectUri,\n      client_id: clientId,\n      code_verifier: codeVerifier,\n    }),\n  });\n\n  if (!tokenResponse.ok) {\n    const errorData = await tokenResponse.json().catch(() => ({}));\n    throw new Error(\n      `Token exchange failed: ${errorData.error_description || tokenResponse.statusText}`\n    );\n  }\n\n  const tokens = await tokenResponse.json();\n\n  // Create session with cookie (tokens stored server-side)\n  // The server will store the tokens and return a session cookie\n  const sessionInfo = await createSession(serverUrl, namespace, {\n    clientId,\n    userDid: tokens.sub, // DID from token response\n    atpSessionId: tokens.session_id, // ATP session ID if present\n  });\n\n  // Clean up OAuth state\n  storage.remove('codeVerifier');\n  storage.remove('oauthState');\n  storage.remove('redirectUri');\n\n  // Clear URL params\n  window.history.replaceState({}, document.title, window.location.pathname);\n\n  return sessionInfo;\n}\n\n/**\n * Logout - destroy session and clear local data\n */\nexport async function logout(\n  storage: Storage,\n  namespace: string,\n  serverUrl: string,\n  options: { reload?: boolean } = {}\n): Promise<void> {\n  // Destroy server-side session (clears cookie)\n  await destroySession(serverUrl);\n\n  // Clear local storage\n  storage.clear();\n  await clearDPoPKeys(namespace);\n\n  if (options.reload !== false) {\n    window.location.reload();\n  }\n}\n", "import { createDPoPProof } from './auth/dpop';\n\nexport interface GraphQLResponse<T = unknown> {\n  data?: T;\n  errors?: Array<{ message: string; path?: string[] }>;\n}\n\n/**\n * Execute a GraphQL query or mutation\n *\n * With cookie-based auth, the session cookie is automatically included\n * via credentials: 'include'. DPoP proof is still added for request binding.\n */\nexport async function graphqlRequest<T = unknown>(\n  namespace: string,\n  graphqlUrl: string,\n  query: string,\n  variables: Record<string, unknown> = {},\n  requireAuth = false,\n  signal?: AbortSignal\n): Promise<T> {\n  const headers: Record<string, string> = {\n    'Content-Type': 'application/json',\n  };\n\n  // Add DPoP proof for authenticated requests\n  // The session cookie is sent automatically with credentials: 'include'\n  if (requireAuth) {\n    // Create DPoP proof bound to this request (no access token hash since tokens are server-side)\n    const dpopProof = await createDPoPProof(namespace, 'POST', graphqlUrl);\n    headers['DPoP'] = dpopProof;\n  }\n\n  const response = await fetch(graphqlUrl, {\n    method: 'POST',\n    headers,\n    body: JSON.stringify({ query, variables }),\n    credentials: 'include', // Include session cookie\n    signal,\n  });\n\n  if (!response.ok) {\n    throw new Error(`GraphQL request failed: ${response.statusText}`);\n  }\n\n  const result: GraphQLResponse<T> = await response.json();\n\n  if (result.errors && result.errors.length > 0) {\n    throw new Error(`GraphQL error: ${result.errors[0].message}`);\n  }\n\n  return result.data as T;\n}\n", "import { createStorageKeys } from './storage/keys';\nimport { createStorage, Storage } from './storage/storage';\nimport { getOrCreateDPoPKey } from './auth/dpop';\nimport { initiateLogin, handleOAuthCallback, logout as doLogout, LoginOptions } from './auth/oauth';\nimport { getSession, SessionInfo } from './auth/session';\nimport { graphqlRequest } from './graphql';\nimport { generateNamespaceHash } from './utils/crypto';\n\nexport interface QuicksliceClientOptions {\n  server: string;\n  clientId: string;\n  redirectUri?: string;\n  scope?: string;\n}\n\nexport interface User {\n  did: string;\n  handle?: string;\n}\n\nexport interface QueryOptions {\n  signal?: AbortSignal;\n}\n\nexport class QuicksliceClient {\n  private server: string;\n  private clientId: string;\n  private redirectUri?: string;\n  private scope?: string;\n  private graphqlUrl: string;\n  private authorizeUrl: string;\n  private tokenUrl: string;\n  private initialized = false;\n  private namespace: string = '';\n  private storage: Storage | null = null;\n  private cachedSession: SessionInfo | null = null;\n\n  constructor(options: QuicksliceClientOptions) {\n    this.server = options.server.replace(/\\/$/, ''); // Remove trailing slash\n    this.clientId = options.clientId;\n    this.redirectUri = options.redirectUri;\n    this.scope = options.scope;\n\n    this.graphqlUrl = `${this.server}/graphql`;\n    this.authorizeUrl = `${this.server}/oauth/authorize`;\n    this.tokenUrl = `${this.server}/oauth/token`;\n  }\n\n  /**\n   * Initialize the client - must be called before other methods\n   */\n  async init(): Promise<void> {\n    if (this.initialized) return;\n\n    // Generate namespace from clientId\n    this.namespace = await generateNamespaceHash(this.clientId);\n\n    // Create namespaced storage\n    const keys = createStorageKeys(this.namespace);\n    this.storage = createStorage(keys);\n\n    // Ensure DPoP key exists\n    await getOrCreateDPoPKey(this.namespace);\n\n    this.initialized = true;\n  }\n\n  private getStorage(): Storage {\n    if (!this.storage) {\n      throw new Error('Client not initialized. Call init() first.');\n    }\n    return this.storage;\n  }\n\n  /**\n   * Start OAuth login flow\n   */\n  async loginWithRedirect(options: LoginOptions = {}): Promise<void> {\n    await this.init();\n    await initiateLogin(this.getStorage(), this.authorizeUrl, this.clientId, {\n      ...options,\n      redirectUri: options.redirectUri || this.redirectUri,\n      scope: options.scope || this.scope,\n    });\n  }\n\n  /**\n   * Handle OAuth callback after redirect\n   * Returns the session info if callback was handled, null otherwise\n   */\n  async handleRedirectCallback(): Promise<SessionInfo | null> {\n    await this.init();\n    const session = await handleOAuthCallback(\n      this.getStorage(),\n      this.namespace,\n      this.tokenUrl,\n      this.server\n    );\n    if (session) {\n      this.cachedSession = session;\n    }\n    return session;\n  }\n\n  /**\n   * Logout and clear all stored data\n   */\n  async logout(options: { reload?: boolean } = {}): Promise<void> {\n    await this.init();\n    this.cachedSession = null;\n    await doLogout(this.getStorage(), this.namespace, this.server, options);\n  }\n\n  /**\n   * Check if user is authenticated\n   * Queries the server to verify session is valid\n   */\n  async isAuthenticated(): Promise<boolean> {\n    await this.init();\n    const session = await getSession(this.server);\n    this.cachedSession = session;\n    return session.authenticated;\n  }\n\n  /**\n   * Get current user info from session\n   * For richer profile info, use client.query() with your own schema\n   */\n  async getUser(): Promise<User | null> {\n    await this.init();\n\n    // Use cached session if available, otherwise fetch\n    let session = this.cachedSession;\n    if (!session) {\n      session = await getSession(this.server);\n      this.cachedSession = session;\n    }\n\n    if (!session.authenticated || !session.did) {\n      return null;\n    }\n\n    return {\n      did: session.did,\n      handle: session.handle ?? undefined,\n    };\n  }\n\n  /**\n   * Execute a GraphQL query (authenticated)\n   * Uses session cookie for auth - no client-side token management\n   */\n  async query<T = unknown>(\n    query: string,\n    variables: Record<string, unknown> = {},\n    options: QueryOptions = {}\n  ): Promise<T> {\n    await this.init();\n    return await graphqlRequest<T>(\n      this.namespace,\n      this.graphqlUrl,\n      query,\n      variables,\n      true,\n      options.signal\n    );\n  }\n\n  /**\n   * Execute a GraphQL mutation (authenticated)\n   */\n  async mutate<T = unknown>(\n    mutation: string,\n    variables: Record<string, unknown> = {},\n    options: QueryOptions = {}\n  ): Promise<T> {\n    return this.query<T>(mutation, variables, options);\n  }\n\n  /**\n   * Execute a public GraphQL query (no auth)\n   */\n  async publicQuery<T = unknown>(\n    query: string,\n    variables: Record<string, unknown> = {},\n    options: QueryOptions = {}\n  ): Promise<T> {\n    await this.init();\n    return await graphqlRequest<T>(\n      this.namespace,\n      this.graphqlUrl,\n      query,\n      variables,\n      false,\n      options.signal\n    );\n  }\n}\n", "/**\n * Base error class for Quickslice client errors\n */\nexport class QuicksliceError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'QuicksliceError';\n  }\n}\n\n/**\n * Thrown when authentication is required but user is not logged in\n */\nexport class LoginRequiredError extends QuicksliceError {\n  constructor(message = 'Login required') {\n    super(message);\n    this.name = 'LoginRequiredError';\n  }\n}\n\n/**\n * Thrown when network request fails\n */\nexport class NetworkError extends QuicksliceError {\n  constructor(message: string) {\n    super(message);\n    this.name = 'NetworkError';\n  }\n}\n\n/**\n * Thrown when OAuth flow fails\n */\nexport class OAuthError extends QuicksliceError {\n  public code: string;\n  public description?: string;\n\n  constructor(code: string, description?: string) {\n    super(`OAuth error: ${code}${description ? ` - ${description}` : ''}`);\n    this.name = 'OAuthError';\n    this.code = code;\n    this.description = description;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
